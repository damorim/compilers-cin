!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	0.0.0	/3fdf28bc/
$(DBG)	makefile	/^$(DBG): $(SOURCE) $(HEADER)$/;"	t
$(EXE)	makefile	/^$(EXE): $(SOURCE) $(HEADER)$/;"	t
ASSIGN_STATEMENT	include/ast.h	/^	ASSIGN_STATEMENT,$/;"	e	enum:AST_Types
AST	include/ast.h	/^typedef union AST AST;$/;"	t	typeref:union:AST
AST	include/ast.h	/^union AST {$/;"	u
AST_HEADER	include/ast.h	/^#define AST_HEADER$/;"	d
AST_Types	include/ast.h	/^enum AST_Types {$/;"	g
AbbrevToken	include/ast.h	/^struct AbbrevToken {$/;"	s
AbbrevToken	include/ast.h	/^typedef struct AbbrevToken AbbrevToken;$/;"	t	typeref:struct:AbbrevToken
BINARY_EXPRESSION	include/ast.h	/^	BINARY_EXPRESSION,$/;"	e	enum:AST_Types
CFLAGS	makefile	/^CFLAGS = -flto -Wall -Wno-parentheses -Wno-missing-braces -Wno-unused-variable -Wno-unused-but-s/;"	m
DBG	makefile	/^	DBG = compiler_db$/;"	m
DBG	makefile	/^	DBG = compiler_db.exe$/;"	m
DECLARATION	include/ast.h	/^	DECLARATION,$/;"	e	enum:AST_Types
EXE	makefile	/^	EXE = compiler$/;"	m
EXE	makefile	/^	EXE = compiler.exe$/;"	m
EXPRESSION	include/ast.h	/^	EXPRESSION,$/;"	e	enum:AST_Types
EXPRESSION_STATEMENT	include/ast.h	/^	EXPRESSION_STATEMENT,$/;"	e	enum:AST_Types
ExprReturn	include/visitor.h	/^struct ExprReturn {$/;"	s
ExprReturn	include/visitor.h	/^typedef struct ExprReturn ExprReturn;$/;"	t	typeref:struct:ExprReturn
FLOAT	include/lexer.h	/^	FLOAT,          \/\/ floating point number literal$/;"	e	enum:TokenType
FUNCTION_CALL_EXPRESSION	include/ast.h	/^	FUNCTION_CALL_EXPRESSION,$/;"	e	enum:AST_Types
FUNCTION_DECLARATION	include/ast.h	/^	FUNCTION_DECLARATION,$/;"	e	enum:AST_Types
HEADER	makefile	/^HEADER = $(addprefix include\/, lexer.h parser.h ast.h visitor.h)$/;"	m
IDENTIFIER	include/lexer.h	/^	IDENTIFIER,     \/\/ variable or function name$/;"	e	enum:TokenType
IDENTIFIER_EXPRESSION	include/ast.h	/^	IDENTIFIER_EXPRESSION,$/;"	e	enum:AST_Types
INI_MAX_COLUMNS	src/ast.c	/^#define INI_MAX_COLUMNS /;"	d	file:
INI_MAX_ROWS	src/ast.c	/^#define INI_MAX_ROWS /;"	d	file:
INTEGER	include/lexer.h	/^	INTEGER,        \/\/ integer number literal$/;"	e	enum:TokenType
LEXER_HEADER	include/lexer.h	/^#define LEXER_HEADER$/;"	d
LITERAL_EXPRESSION	include/ast.h	/^	LITERAL_EXPRESSION,$/;"	e	enum:AST_Types
List	include/ast.h	/^struct List {$/;"	s
List	include/ast.h	/^typedef struct List List;$/;"	t	typeref:struct:List
Memory	src/ast.c	/^struct Memory {$/;"	s	file:
Memory	src/ast.c	/^typedef struct Memory Memory;$/;"	t	typeref:struct:Memory	file:
NO_TYPE	include/lexer.h	/^	NO_TYPE,        \/\/ identifier has no type (not used in lexer, but later)$/;"	e	enum:TypeType
OUT	makefile	/^	OUT = tmp.exe$/;"	m
OUT	makefile	/^	OUT = tmp.out$/;"	m
PARSER_HEADER	include/parser.h	/^#define PARSER_HEADER$/;"	d
RETURN	include/lexer.h	/^	RETURN,         \/\/ return$/;"	e	enum:TokenType
RETURN_STATEMENT	include/ast.h	/^	RETURN_STATEMENT,$/;"	e	enum:AST_Types
SOURCE	makefile	/^SOURCE = $(addprefix src\/, lexer.c parser.c ast.c visitor.c main.c)$/;"	m
STATEMENT	include/ast.h	/^	STATEMENT,$/;"	e	enum:AST_Types
STRING	include/lexer.h	/^	STRING,         \/\/ a string delimited by " "$/;"	e	enum:TokenType
STRING_SIZE	src/lexer.c	/^#define STRING_SIZE /;"	d	file:
TYPE	include/lexer.h	/^	TYPE,           \/\/ the type of the type is specified at enum TypeType$/;"	e	enum:TokenType
TYPE_FLOAT	include/lexer.h	/^	TYPE_FLOAT,$/;"	e	enum:TypeType
TYPE_INT	include/lexer.h	/^	TYPE_INT,$/;"	e	enum:TypeType
TYPE_STRING	include/lexer.h	/^	TYPE_STRING,    \/\/ placeholder for char * (not used in lexer, but later)$/;"	e	enum:TypeType
TYPE_VOID	include/lexer.h	/^	TYPE_VOID,      \/\/ only functions may be void$/;"	e	enum:TypeType
Token	include/lexer.h	/^struct Token {$/;"	s
Token	include/lexer.h	/^typedef struct Token Token;$/;"	t	typeref:struct:Token
TokenType	include/lexer.h	/^enum TokenType {$/;"	g
TypeType	include/lexer.h	/^enum TypeType {$/;"	g
UNARY_MINUS_EXPRESSION	include/ast.h	/^	UNARY_MINUS_EXPRESSION,$/;"	e	enum:AST_Types
UNKNOWN	include/lexer.h	/^	UNKNOWN = 0x80, \/\/ unrecognized character$/;"	e	enum:TokenType
VARIABLE_DECLARATION	include/ast.h	/^	VARIABLE_DECLARATION,$/;"	e	enum:AST_Types
VARIABLE_DECLARATION_LIST	include/ast.h	/^	VARIABLE_DECLARATION_LIST,$/;"	e	enum:AST_Types
VISITOR_HEADER	include/visitor.h	/^#define VISITOR_HEADER$/;"	d
__anon0050531e010a	include/visitor.h	/^	union {$/;"	u	struct:ExprReturn
__anon7ad9106d0103	src/lexer.c	/^enum { false, true };$/;"	g	file:
__anona4e73416010a	include/ast.h	/^    union {$/;"	u	union:AST
__anona4e734160208	include/ast.h	/^        struct {$/;"	s	union:AST::__anona4e73416010a
__anona4e734160308	include/ast.h	/^        struct {$/;"	s	union:AST::__anona4e73416010a
__anona4e734160408	include/ast.h	/^    struct {$/;"	s	union:AST
__anona4e734160508	include/ast.h	/^    struct {$/;"	s	union:AST
__anona4e73416060a	include/ast.h	/^        union {$/;"	u	struct:AST::__anona4e734160508
__anona4e734160708	include/ast.h	/^            struct {$/;"	s	union:AST::__anona4e734160508::__anona4e73416060a
__anona4e734160808	include/ast.h	/^            struct {$/;"	s	union:AST::__anona4e734160508::__anona4e73416060a
__anona4e734160908	include/ast.h	/^            struct {$/;"	s	union:AST::__anona4e734160508::__anona4e73416060a
__anona4e734160a08	include/ast.h	/^            struct {$/;"	s	union:AST::__anona4e734160508::__anona4e73416060a
__anona4e734160b08	include/ast.h	/^    struct {$/;"	s	union:AST
__anona4e734160c0a	include/ast.h	/^        union {$/;"	u	struct:AST::__anona4e734160b08
__anona4e734160d08	include/ast.h	/^            struct {$/;"	s	union:AST::__anona4e734160b08::__anona4e734160c0a
__anona4e734160e08	include/ast.h	/^            struct {$/;"	s	union:AST::__anona4e734160b08::__anona4e734160c0a
__anona4e734160f08	include/ast.h	/^            struct {$/;"	s	union:AST::__anona4e734160b08::__anona4e734160c0a
__anona4e73416100a	include/ast.h	/^				union {$/;"	u	struct:AST::__anona4e734160b08::__anona4e734160c0a::__anona4e734160f08
__anona4e734161108	include/ast.h	/^            struct {$/;"	s	union:AST::__anona4e734160b08::__anona4e734160c0a
__anona4e734161208	include/ast.h	/^            struct {$/;"	s	union:AST::__anona4e734160b08::__anona4e734160c0a
__anona4e734161308	include/ast.h	/^    struct {$/;"	s	union:AST
__anona4e73416140a	include/ast.h	/^		union {$/;"	u	struct:AST::__anona4e734161308
__anonaa03b0ce010a	include/lexer.h	/^	union {$/;"	u	struct:Token
__anonb4d85ab5010a	src/ast.c	/^    union {$/;"	u	struct:Memory	file:
a	test_ok.c	/^int a = -3 * (5 - 2) + 1;$/;"	v	typeref:typename:int
add_to_file	src/ast.c	/^AST *add_to_file (AST *file, AST *decl) {$/;"	f	typeref:typename:AST *
add_to_list	src/ast.c	/^AST *add_to_list (AST *list, AST *node) {$/;"	f	typeref:typename:AST *
all	makefile	/^all: tags $(EXE) $(DBG) compiler.s$/;"	t
all_columns_full	src/ast.c	/^#define all_columns_full(/;"	d	file:
alloc_ast	src/ast.c	/^AST *alloc_ast () {$/;"	f	typeref:typename:AST *
alloc_astptr	src/ast.c	/^List *alloc_astptr () {$/;"	f	typeref:typename:List *
alloc_id	src/ast.c	/^AST *alloc_id () {$/;"	f	typeref:typename:AST *
alloc_str	src/ast.c	/^char *alloc_str (int length) {$/;"	f	typeref:typename:char *
array	src/ast.c	/^        AST **array;$/;"	m	union:Memory::__anonb4d85ab5010a	typeref:typename:AST **	file:
asm	makefile	/^asm: compiler.s$/;"	t
assign	include/ast.h	/^            } assign;$/;"	m	union:AST::__anona4e734160508::__anona4e73416060a	typeref:struct:AST::__anona4e734160508::__anona4e73416060a::__anona4e734160808
assign_token	include/ast.h	/^			AbbrevToken *assign_token;$/;"	m	struct:AST::__anona4e73416010a::__anona4e734160308	typeref:typename:AbbrevToken *
ast	include/ast.h	/^    AST *ast;$/;"	m	struct:List	typeref:typename:AST *
ast	src/ast.c	/^} ast, astptr, str, id_buffer, token_buffer;$/;"	v	typeref:struct:Memory
aster	test_error.c	/^float aster (float red, float green, float blue) {$/;"	f	typeref:typename:float
astptr	src/ast.c	/^} ast, astptr, str, id_buffer, token_buffer;$/;"	v	typeref:struct:Memory
b	test_ok.c	/^int b = +1;$/;"	v	typeref:typename:int
b	test_ok.c	/^int b = -4 + a * 3;$/;"	v	typeref:typename:int
binary_expr	include/ast.h	/^            } binary_expr; \/\/ '+', '-', '*', '\/' '%'$/;"	m	union:AST::__anona4e734160b08::__anona4e734160c0a	typeref:struct:AST::__anona4e734160b08::__anona4e734160c0a::__anona4e734160d08
block	include/ast.h	/^            AST *block;$/;"	m	struct:AST::__anona4e73416010a::__anona4e734160208	typeref:typename:AST *
buffpos	include/lexer.h	/^	char *buffpos;     \/\/ pointer to next character to be read$/;"	m	struct:Token	typeref:typename:char *
c	test_ok.c	/^int c = a \/ b * - 1;$/;"	v	typeref:typename:int
clean	makefile	/^clean:$/;"	t
column	include/ast.h	/^	int line, column;$/;"	m	struct:AbbrevToken	typeref:typename:int
column	include/lexer.h	/^	int column;    \/\/ column in current line where the token starts$/;"	m	struct:Token	typeref:typename:int
columns_allocated	src/ast.c	/^    int columns_allocated;$/;"	m	struct:Memory	typeref:typename:int	file:
compiler.s	makefile	/^compiler.s: $(SOURCE) $(HEADER)$/;"	t
current_column	src/ast.c	/^    int current_column;$/;"	m	struct:Memory	typeref:typename:int	file:
current_row	src/ast.c	/^    int current_row; \/\/ at current column$/;"	m	struct:Memory	typeref:typename:int	file:
d	test_ok.c	/^int d = c * a + b \/ c - a;$/;"	v	typeref:typename:int
debug	makefile	/^debug: $(DBG)$/;"	t
decl	include/ast.h	/^    } decl;$/;"	m	union:AST	typeref:union:AST::__anona4e73416010a
decl_type	include/ast.h	/^		int decl_type; \/\/ VARIABLE_DECLARATION or FUNCTION_DECLARATION$/;"	m	struct:AST::__anona4e734161308	typeref:typename:int
decl_type	include/ast.h	/^            int decl_type; \/\/ useless space to align union fields$/;"	m	struct:AST::__anona4e73416010a::__anona4e734160208	typeref:typename:int
decl_type	include/ast.h	/^            int decl_type; \/\/ useless space to align union fields$/;"	m	struct:AST::__anona4e73416010a::__anona4e734160308	typeref:typename:int
declaration	include/ast.h	/^		AST *declaration;$/;"	m	struct:AST::__anona4e734161308	typeref:typename:AST *
e	test_ok.c	/^int e = a - b + c * -d;$/;"	v	typeref:typename:int
empty	test_error.c	/^void empty () {$/;"	f	typeref:typename:void
err	src/lexer.c	/^#define err(/;"	d	file:
err	src/main.c	/^#define err(/;"	d	file:
err	src/parser.c	/^#define err(/;"	d	file:
expr	include/ast.h	/^                AST *expr; \/\/ TODO: remove this indirection$/;"	m	struct:AST::__anona4e734160508::__anona4e73416060a::__anona4e734160a08	typeref:typename:AST *
expr	include/ast.h	/^                AST *expr;$/;"	m	struct:AST::__anona4e734160508::__anona4e73416060a::__anona4e734160708	typeref:typename:AST *
expr	include/ast.h	/^                AST *expr;$/;"	m	struct:AST::__anona4e734160508::__anona4e73416060a::__anona4e734160808	typeref:typename:AST *
expr	include/ast.h	/^                AST *expr;$/;"	m	struct:AST::__anona4e734160508::__anona4e73416060a::__anona4e734160908	typeref:typename:AST *
expr	include/ast.h	/^                AST *expr;$/;"	m	struct:AST::__anona4e734160b08::__anona4e734160c0a::__anona4e734160e08	typeref:typename:AST *
expr	include/ast.h	/^            AST *expr;$/;"	m	struct:AST::__anona4e73416010a::__anona4e734160308	typeref:typename:AST *
expr	include/ast.h	/^            } expr;$/;"	m	union:AST::__anona4e734160508::__anona4e73416060a	typeref:struct:AST::__anona4e734160508::__anona4e73416060a::__anona4e734160a08
expr	include/ast.h	/^    } expr; \/\/ base type$/;"	m	union:AST	typeref:struct:AST::__anona4e734160b08
expr_list	include/ast.h	/^                AST *expr_list;$/;"	m	struct:AST::__anona4e734160b08::__anona4e734160c0a::__anona4e734161208	typeref:typename:AST *
file_buffer	include/lexer.h	/^	char *file_buffer; \/\/ pointer to start of the file$/;"	m	struct:Token	typeref:typename:char *
filename	include/ast.h	/^	char *filename, *line_start;$/;"	m	struct:AbbrevToken	typeref:typename:char *
filename	include/lexer.h	/^	char *filename;    \/\/ name of the file read by the lexer$/;"	m	struct:Token	typeref:typename:char *
first	include/ast.h	/^        List *first;$/;"	m	struct:AST::__anona4e734160408	typeref:typename:List *
float_value	include/ast.h	/^					double float_value;$/;"	m	union:AST::__anona4e734160b08::__anona4e734160c0a::__anona4e734160f08::__anona4e73416100a	typeref:typename:double
float_value	include/ast.h	/^			double float_value;$/;"	m	union:AST::__anona4e734161308::__anona4e73416140a	typeref:typename:double
float_value	include/lexer.h	/^		double float_value; \/\/ value of the floating point literal token$/;"	m	union:Token::__anonaa03b0ce010a	typeref:typename:double
float_value	include/visitor.h	/^		double float_value;$/;"	m	union:ExprReturn::__anon0050531e010a	typeref:typename:double
function	include/ast.h	/^        } function;$/;"	m	union:AST::__anona4e73416010a	typeref:struct:AST::__anona4e73416010a::__anona4e734160208
function	test_error.c	/^int function (int a, int b) {$/;"	f	typeref:typename:int
function_call	include/ast.h	/^            } function_call;$/;"	m	union:AST::__anona4e734160b08::__anona4e734160c0a	typeref:struct:AST::__anona4e734160b08::__anona4e734160c0a::__anona4e734161208
hash	include/ast.h	/^        int hash;$/;"	m	struct:AST::__anona4e734161308	typeref:typename:int
id	include/ast.h	/^                AST *id;$/;"	m	struct:AST::__anona4e734160508::__anona4e73416060a::__anona4e734160708	typeref:typename:AST *
id	include/ast.h	/^                AST *id;$/;"	m	struct:AST::__anona4e734160508::__anona4e73416060a::__anona4e734160808	typeref:typename:AST *
id	include/ast.h	/^                AST *id;$/;"	m	struct:AST::__anona4e734160b08::__anona4e734160c0a::__anona4e734161108	typeref:typename:AST *
id	include/ast.h	/^                AST *id;$/;"	m	struct:AST::__anona4e734160b08::__anona4e734160c0a::__anona4e734161208	typeref:typename:AST *
id	include/ast.h	/^            AST *id;$/;"	m	struct:AST::__anona4e73416010a::__anona4e734160208	typeref:typename:AST *
id	include/ast.h	/^            AST *id;$/;"	m	struct:AST::__anona4e73416010a::__anona4e734160308	typeref:typename:AST *
id	include/ast.h	/^            } id;$/;"	m	union:AST::__anona4e734160b08::__anona4e734160c0a	typeref:struct:AST::__anona4e734160b08::__anona4e734160c0a::__anona4e734161108
id	include/ast.h	/^    } id;$/;"	m	union:AST	typeref:struct:AST::__anona4e734161308
id_buffer	src/ast.c	/^} ast, astptr, str, id_buffer, token_buffer;$/;"	v	typeref:struct:Memory
id_hash	include/lexer.h	/^		long id_hash;       \/\/ hash of the identifier's string$/;"	m	union:Token::__anonaa03b0ce010a	typeref:typename:long
init_memory	src/ast.c	/^void init_memory () {$/;"	f	typeref:typename:void
int_value	include/ast.h	/^					long int_value;$/;"	m	union:AST::__anona4e734160b08::__anona4e734160c0a::__anona4e734160f08::__anona4e73416100a	typeref:typename:long
int_value	include/ast.h	/^			long int_value;$/;"	m	union:AST::__anona4e734161308::__anona4e73416140a	typeref:typename:long
int_value	include/lexer.h	/^		long int_value;     \/\/ value of the integer literal token$/;"	m	union:Token::__anonaa03b0ce010a	typeref:typename:long
int_value	include/visitor.h	/^		long int_value;$/;"	m	union:ExprReturn::__anon0050531e010a	typeref:typename:long
jenkins_hash	src/lexer.c	/^int jenkins_hash (char *string, int length) {$/;"	f	typeref:typename:int
keywords_strings	src/lexer.c	/^char keywords_strings[] = "int\\nfloat\\nvoid\\nreturn\\n";$/;"	v	typeref:typename:char[]
keywords_types	src/lexer.c	/^unsigned char keywords_types[] = { TYPE_INT, TYPE_FLOAT, TYPE_VOID, RETURN };$/;"	v	typeref:typename:unsigned char[]
last	include/ast.h	/^        List *last;$/;"	m	struct:AST::__anona4e734160408	typeref:typename:List *
left_expr	include/ast.h	/^                AST *left_expr;$/;"	m	struct:AST::__anona4e734160b08::__anona4e734160c0a::__anona4e734160d08	typeref:typename:AST *
length	include/ast.h	/^        int length;$/;"	m	struct:AST::__anona4e734161308	typeref:typename:int
length	include/lexer.h	/^	int length;    \/\/ length of the token$/;"	m	struct:Token	typeref:typename:int
line	include/ast.h	/^	int line, column;$/;"	m	struct:AbbrevToken	typeref:typename:int
line	include/lexer.h	/^	int line;      \/\/ line of the token$/;"	m	struct:Token	typeref:typename:int
line_span	include/lexer.h	/^	int line_span; \/\/ number of lines the token spans$/;"	m	struct:Token	typeref:typename:int
line_start	include/ast.h	/^	char *filename, *line_start;$/;"	m	struct:AbbrevToken	typeref:typename:char **
line_start	include/lexer.h	/^	char *line_start;  \/\/ pointer to start of line where buffpos is$/;"	m	struct:Token	typeref:typename:char *
list	include/ast.h	/^    } list; \/\/ expr_list param_decl_list stat_block\/block file var_decl_list$/;"	m	union:AST	typeref:struct:AST::__anona4e734160408
literal	include/ast.h	/^            } literal;$/;"	m	union:AST::__anona4e734160b08::__anona4e734160c0a	typeref:struct:AST::__anona4e734160b08::__anona4e734160c0a::__anona4e734160f08
locate_id	src/ast.c	/^AST *locate_id (char *string, int hash, int length) {$/;"	f	typeref:typename:AST *
main	src/main.c	/^int main (int argc, char **argv) {$/;"	f	typeref:typename:int
main	test_error.c	/^int main () {$/;"	f	typeref:typename:int
main	test_ok.c	/^int main (int a, int b) {$/;"	f	typeref:typename:int
new_abbrev_token	src/ast.c	/^AbbrevToken *new_abbrev_token (Token *token) {$/;"	f	typeref:typename:AbbrevToken *
new_assign_stat	src/ast.c	/^AST *new_assign_stat (AST *id, AST *expr, Token *token) {$/;"	f	typeref:typename:AST *
new_binary_expr	src/ast.c	/^AST *new_binary_expr (AST *left_expr, char op, AST *right_expr, Token *token) {$/;"	f	typeref:typename:AST *
new_expr_stat	src/ast.c	/^AST *new_expr_stat (AST *expr) {$/;"	f	typeref:typename:AST *
new_file	src/ast.c	/^AST *new_file (AST *decl) {$/;"	f	typeref:typename:AST *
new_function_call	src/ast.c	/^AST *new_function_call (AST *id, AST *expr_list, Token *token) {$/;"	f	typeref:typename:AST *
new_function_decl	src/ast.c	/^AST *new_function_decl (int type, AST *id, AST *param_decl_list, AST *block, Token *token) {$/;"	f	typeref:typename:AST *
new_id_expr	src/ast.c	/^AST *new_id_expr (AST *id, Token *token) {$/;"	f	typeref:typename:AST *
new_identifier	src/ast.c	/^AST *new_identifier (Token *token) {$/;"	f	typeref:typename:AST *
new_list	src/ast.c	/^AST *new_list (AST *node) {$/;"	f	typeref:typename:AST *
new_literal	src/ast.c	/^AST *new_literal (int type, void *value, Token *token) {$/;"	f	typeref:typename:AST *
new_return_stat	src/ast.c	/^AST *new_return_stat (AST *expr, Token *token) {$/;"	f	typeref:typename:AST *
new_unary_minus	src/ast.c	/^AST *new_unary_minus (AST *expr, Token *token) {$/;"	f	typeref:typename:AST *
new_var_decl	src/ast.c	/^AST *new_var_decl (int type, AST *id, AST *expr, Token *token, Token *assign_token) {$/;"	f	typeref:typename:AST *
new_var_decl_list	src/ast.c	/^AST *new_var_decl_list (AST *ast) {$/;"	f	typeref:typename:AST *
next	include/ast.h	/^    List *next;$/;"	m	struct:List	typeref:typename:List *
next_token	src/lexer.c	/^int next_token (Token *restrict token) {$/;"	f	typeref:typename:int
num_items	include/ast.h	/^        int num_items;$/;"	m	struct:AST::__anona4e734160408	typeref:typename:int
operation	include/ast.h	/^				char operation;$/;"	m	struct:AST::__anona4e734160b08::__anona4e734160c0a::__anona4e734160d08	typeref:typename:char
param_decl_list	include/ast.h	/^            AST *param_decl_list;$/;"	m	struct:AST::__anona4e73416010a::__anona4e734160208	typeref:typename:AST *
parse_declaration	src/parser.c	/^AST *parse_declaration (Token *token) {$/;"	f	typeref:typename:AST *
parse_declaration_parameters	src/parser.c	/^AST *parse_declaration_parameters (Token *token) {$/;"	f	typeref:typename:AST *
parse_expression	include/parser.h	/^#define parse_expression(/;"	d
parse_expression_op	src/parser.c	/^AST *parse_expression_op (Token *token, int prev_op) {$/;"	f	typeref:typename:AST *
parse_file	src/parser.c	/^AST *parse_file (const char *filename) {$/;"	f	typeref:typename:AST *
parse_statement	src/parser.c	/^AST *parse_statement (Token *token) {$/;"	f	typeref:typename:AST *
printm	src/visitor.c	/^#define printm(/;"	d	file:
ptrs	src/ast.c	/^        List **ptrs;$/;"	m	union:Memory::__anonb4d85ab5010a	typeref:typename:List **	file:
read_file	src/parser.c	/^static char *read_file (const char *filename) {$/;"	f	typeref:typename:char *	file:
release	makefile	/^release: $(EXE)$/;"	t
resize_if_needed	src/ast.c	/^void resize_if_needed (Memory* mem, unsigned long type_size, int input_length) {$/;"	f	typeref:typename:void
ret	include/ast.h	/^            } ret;$/;"	m	union:AST::__anona4e734160508::__anona4e73416060a	typeref:struct:AST::__anona4e734160508::__anona4e73416060a::__anona4e734160908
right_expr	include/ast.h	/^                AST *right_expr;$/;"	m	struct:AST::__anona4e734160b08::__anona4e734160c0a::__anona4e734160d08	typeref:typename:AST *
root	src/ast.c	/^AST *root = NULL;$/;"	v	typeref:typename:AST *
row_full	src/ast.c	/^#define row_full(/;"	d	file:
rows_allocated	src/ast.c	/^    int rows_allocated; \/\/ at current column$/;"	m	struct:Memory	typeref:typename:int	file:
start	include/lexer.h	/^	char *start;       \/\/ pointer to the start of the token just read$/;"	m	struct:Token	typeref:typename:char *
stat	include/ast.h	/^    } stat; \/\/ base type$/;"	m	union:AST	typeref:struct:AST::__anona4e734160508
str	src/ast.c	/^} ast, astptr, str, id_buffer, token_buffer;$/;"	v	typeref:struct:Memory
string	include/ast.h	/^        char *string;$/;"	m	struct:AST::__anona4e734161308	typeref:typename:char *
strings	src/ast.c	/^        char **strings;$/;"	m	union:Memory::__anonb4d85ab5010a	typeref:typename:char **	file:
strline	src/lexer.c	/^char *strline (const Token *restrict token) {$/;"	f	typeref:typename:char *
strtoken	src/lexer.c	/^char *strtoken (const Token *restrict token) {$/;"	f	typeref:typename:char *
tags	makefile	/^tags: $(SOURCE) $(HEADER)$/;"	t
token	include/ast.h	/^				AbbrevToken *token;$/;"	m	struct:AST::__anona4e734160508::__anona4e73416060a::__anona4e734160708	typeref:typename:AbbrevToken *
token	include/ast.h	/^				AbbrevToken *token;$/;"	m	struct:AST::__anona4e734160508::__anona4e73416060a::__anona4e734160808	typeref:typename:AbbrevToken *
token	include/ast.h	/^				AbbrevToken *token;$/;"	m	struct:AST::__anona4e734160508::__anona4e73416060a::__anona4e734160908	typeref:typename:AbbrevToken *
token	include/ast.h	/^				AbbrevToken *token;$/;"	m	struct:AST::__anona4e734160b08::__anona4e734160c0a::__anona4e734160d08	typeref:typename:AbbrevToken *
token	include/ast.h	/^				AbbrevToken *token;$/;"	m	struct:AST::__anona4e734160b08::__anona4e734160c0a::__anona4e734160e08	typeref:typename:AbbrevToken *
token	include/ast.h	/^				AbbrevToken *token;$/;"	m	struct:AST::__anona4e734160b08::__anona4e734160c0a::__anona4e734160f08	typeref:typename:AbbrevToken *
token	include/ast.h	/^				AbbrevToken *token;$/;"	m	struct:AST::__anona4e734160b08::__anona4e734160c0a::__anona4e734161108	typeref:typename:AbbrevToken *
token	include/ast.h	/^				AbbrevToken *token;$/;"	m	struct:AST::__anona4e734160b08::__anona4e734160c0a::__anona4e734161208	typeref:typename:AbbrevToken *
token	include/ast.h	/^			AbbrevToken *token;$/;"	m	struct:AST::__anona4e73416010a::__anona4e734160208	typeref:typename:AbbrevToken *
token	include/ast.h	/^			AbbrevToken *token;$/;"	m	struct:AST::__anona4e73416010a::__anona4e734160308	typeref:typename:AbbrevToken *
token_buffer	src/ast.c	/^} ast, astptr, str, id_buffer, token_buffer;$/;"	v	typeref:struct:Memory
tokens	src/ast.c	/^		AbbrevToken **tokens;$/;"	m	union:Memory::__anonb4d85ab5010a	typeref:typename:AbbrevToken **	file:
tree	src/ast.c	/^        AST **tree;$/;"	m	union:Memory::__anonb4d85ab5010a	typeref:typename:AST **	file:
type	include/ast.h	/^				int type;$/;"	m	struct:AST::__anona4e734160b08::__anona4e734160c0a::__anona4e734160f08	typeref:typename:int
type	include/ast.h	/^		int type; \/\/ TYPE_INT, TYPE_FLOAT, TYPE_VOID, or TYPE_STRING$/;"	m	struct:AST::__anona4e734161308	typeref:typename:int
type	include/ast.h	/^                int type;$/;"	m	struct:AST::__anona4e734160508::__anona4e73416060a::__anona4e734160708	typeref:typename:int
type	include/ast.h	/^            int type;$/;"	m	struct:AST::__anona4e73416010a::__anona4e734160208	typeref:typename:int
type	include/ast.h	/^            int type;$/;"	m	struct:AST::__anona4e73416010a::__anona4e734160308	typeref:typename:int
type	include/ast.h	/^        int type;$/;"	m	struct:AST::__anona4e734160508	typeref:typename:int
type	include/ast.h	/^        int type;$/;"	m	struct:AST::__anona4e734160b08	typeref:typename:int
type	include/ast.h	/^        int type;$/;"	m	union:AST::__anona4e73416010a	typeref:typename:int
type	include/lexer.h	/^	int type; \/\/ vide enum TokenType$/;"	m	struct:Token	typeref:typename:int
type	include/visitor.h	/^	int type; \/\/ TYPE_INT, TYPE_FLOAT$/;"	m	struct:ExprReturn	typeref:typename:int
type_type	include/lexer.h	/^		long type_type;     \/\/ vide enum TypeType (used if the token type is TYPE)$/;"	m	union:Token::__anonaa03b0ce010a	typeref:typename:long
unary_minus	include/ast.h	/^            } unary_minus;$/;"	m	union:AST::__anona4e734160b08::__anona4e734160c0a	typeref:struct:AST::__anona4e734160b08::__anona4e734160c0a::__anona4e734160e08
var_decl	include/ast.h	/^            } var_decl; \/\/use decl.variable$/;"	m	union:AST::__anona4e734160508::__anona4e73416060a	typeref:struct:AST::__anona4e734160508::__anona4e73416060a::__anona4e734160708
var_decl_list	include/ast.h	/^			List var_decl_list; \/\/ TODO: implement this$/;"	m	union:AST::__anona4e734160508::__anona4e73416060a	typeref:typename:List
variable	include/ast.h	/^        } variable;$/;"	m	union:AST::__anona4e73416010a	typeref:struct:AST::__anona4e73416010a::__anona4e734160308
visit_add	src/visitor.c	/^ExprReturn visit_add (AST *ast) {$/;"	f	typeref:typename:ExprReturn
visit_assign_stat	src/visitor.c	/^void visit_assign_stat (AST *assign) {$/;"	f	typeref:typename:void
visit_block	src/visitor.c	/^ExprReturn visit_block (AST *block, AST *params, int return_type) {$/;"	f	typeref:typename:ExprReturn
visit_div	src/visitor.c	/^ExprReturn visit_div (AST *ast) {$/;"	f	typeref:typename:ExprReturn
visit_expr	src/visitor.c	/^ExprReturn visit_expr (AST *expr) {$/;"	f	typeref:typename:ExprReturn
visit_file	src/visitor.c	/^void visit_file (AST *root) {$/;"	f	typeref:typename:void
visit_function_call	src/visitor.c	/^ExprReturn visit_function_call (AST *ast) {$/;"	f	typeref:typename:ExprReturn
visit_function_decl	src/visitor.c	/^void visit_function_decl (AST *ast) {$/;"	f	typeref:typename:void
visit_id	src/visitor.c	/^ExprReturn visit_id (AST *ast) {$/;"	f	typeref:typename:ExprReturn
visit_literal	src/visitor.c	/^ExprReturn visit_literal (AST *ast) {$/;"	f	typeref:typename:ExprReturn
visit_mod	src/visitor.c	/^ExprReturn visit_mod (AST *ast) {$/;"	f	typeref:typename:ExprReturn
visit_mul	src/visitor.c	/^ExprReturn visit_mul (AST *ast) {$/;"	f	typeref:typename:ExprReturn
visit_return_stat	src/visitor.c	/^ExprReturn visit_return_stat (AST *ast) {$/;"	f	typeref:typename:ExprReturn
visit_stat	src/visitor.c	/^ExprReturn visit_stat (AST *stat) {$/;"	f	typeref:typename:ExprReturn
visit_sub	src/visitor.c	/^ExprReturn visit_sub (AST *ast) {$/;"	f	typeref:typename:ExprReturn
visit_unary_minus	src/visitor.c	/^ExprReturn visit_unary_minus (AST *ast) {$/;"	f	typeref:typename:ExprReturn
visit_var_decl	src/visitor.c	/^void visit_var_decl (AST *ast) {$/;"	f	typeref:typename:void
