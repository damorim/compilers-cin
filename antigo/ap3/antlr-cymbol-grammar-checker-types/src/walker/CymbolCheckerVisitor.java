package walker;

import java.util.HashMap;
import java.util.Map;

import autogenerated.CymbolBaseVisitor;
import autogenerated.CymbolParser;



public class CymbolCheckerVisitor extends CymbolBaseVisitor<Type> {
	public Map<String, Type> symbolTable = new HashMap<String,Type>( ); 
	
	@Override
	public Type visitIntExpr(CymbolParser.IntExprContext ctx) {
		return Type.INT;
	}

	@Override
	public Type visitVarDecl(CymbolParser.VarDeclContext ctx) {
		Type result;
		String varname = ctx.ID( ).getText( );
		String typeName = ctx.type( ).getText( );
		Type type = Type.valueOf(typeName.toUpperCase( ));
		
		if (type.equals(Type.VOID)) {
			result = Type.VOID;
			System.err.println("Mensagem de erro 1...");
			System.exit(1);
		} else {
			
			if (ctx.expr( ) != null) {
				Type init = ctx.expr( ).accept(this);
				if (!init.equals(type)) {
					System.err.println("Mensagem de erro 2...");
					System.exit(2);
				} 
			}
			
			symbolTable.put(varname, type);
			result = type;
		}
		
		return result;
	}

	@Override
	public Type visitAddSubExpr(CymbolParser.AddSubExprContext ctx) {
		Type result;
		Type left = ctx.expr(0).accept(this);
		Type right = ctx.expr(1).accept(this);
		
		if (left.equals(Type.INT) && right.equals(Type.INT)) {
			result = Type.INT;
		} else {
			result = Type.VOID;
			System.err.println("Mensagem de erro 3...");
			System.exit(3);
		}
		
		return result;
	}
	
	@Override
	public Type visitVarIdExpr(CymbolParser.VarIdExprContext ctx) {
		Type result;
		Type t = symbolTable.get(ctx.ID( ).getText( ));
		
		if (t == null) {
			result = Type.VOID;
			System.err.println("Mensagem de erro 4...");
			System.exit(4);
		} else {
			result = t;
		}
		
		return result;
	}

	@Override
	protected Type aggregateResult(Type aggregate, Type nextResult) {
		return (nextResult != null) ? nextResult : aggregate;
	}
}
